/* ==========================================================================

	Abakt - A Backup Tool
	Copyright (C) 2003-2007 - Erik Dienske

	This file is part of Abakt.

	Abakt is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.

	Abakt is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Abakt; if not, write to the Free Software Foundation, Inc.,
	59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

==========================================================================*/

//---------------------------------------------------------------------------
#include <vcl.h>
#pragma hdrstop

#include "Xml_IO.h"
#include "AbaktGlobals.h"
#include "AbaktClasses.h"
#include "eccString.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
//---------------------------------------------------------------------------

bool XmlIO_ParseFile(const String fPath,
	const XML_StartElementHandler& start, const XML_EndElementHandler& end)
{
	// Create parser:
	XML_Parser p = XML_ParserCreate(NULL);
	if (!p)
	{
		ShowMessage(__FUNC__ ": Could not allocate memory for XML-parser");
		return false;
	}

	char* buff;
	int size;
	try
	{
		// Open file:
		std::ifstream ifs(fPath.c_str());
		if (!ifs)
		{
    		ShowMessage(__FUNC__ ": Could not open file: " + ecc::QuoteStr(fPath));
			return false;
		}

		// Create buffer:
		ifs.seekg(0, std::ios::end); 	// set pos to end of file
		size = ifs.tellg();				// get filesize
		buff = new char[size];

		// Read xml file into buffer:
		size = 0;
		ifs.seekg(0);					// set pos to begin of file.
		while (!ifs.eof())
		{
			buff[size++] = ifs.get();
		}
	}
	catch(Exception &err)
	{
        ShowMessage(__FUNC__ ": Error reading file into buffer");
		delete[] buff;
		return false;
	}

	// Start parsing:
	XML_SetElementHandler(p, start, end);

	if (XML_Parse(p, buff, size, 1))
	{
        ShowMessage(__FUNC__ ": XML_Parse failed");
		delete[] buff;
		return false;
	}

	XML_ParserFree(p);
	delete[] buff;
	return true;
}
//---------------------------------------------------------------------------

//===========================================================================
namespace xout {
//===========================================================================

//---------------------------------------------------------------------------

void XmlHeader(std::ofstream &ofs)
{
	ofs << "<?xml version='1.0' encoding='UTF-8'?>" << std::endl;
	ofs	<< std::endl;
	Comment(ofs, 0, "Do not edit this file, unless you know what you are doing.");
}
//---------------------------------------------------------------------------

void rootElement(std::ofstream &ofs, const char* elmName, const String docName)
{
	ofs	<< std::endl
		<< "<" << elmName
		<< " name='" << ecc::StrToXmlUtf8Str(docName).c_str() << "'"
		<< " version='" << PGlobals->AppVersionStr.c_str() << "'"
		<< " build='" << PGlobals->AppBuildStr.c_str() << "'"
		<< ">" << std::endl;
}
//---------------------------------------------------------------------------

void configItemList(std::ofstream& ofs, int tabs, abakt::TItemList* itemlist, bool includeOverride)
{
	// Header:
	StartElm(ofs, tabs, itemlist->name.c_str());

	abakt::TItem* item;
	for (unsigned int i = 0; i < itemlist->size(); i++)
	{
		item = itemlist->at(i);
		switch (item->type())
		{
			case abakt::dtBool:
				itemBool(ofs, tabs + 1, (abakt::TBool*)item, includeOverride);
				break;

			case abakt::dtUIntRange:
				itemUIntRange(ofs, tabs + 1, (abakt::TUIntRange*)item, includeOverride);
				break;

			case abakt::dtText:
				itemText(ofs, tabs + 1, (abakt::TText*)item, includeOverride);
				break;

			case abakt::dtPath:
				itemPath(ofs, tabs + 1, (abakt::TPath*)item, includeOverride);
				break;

			case abakt::dtEnum:
				itemEnum(ofs, tabs + 1, (abakt::TEnum*)item, includeOverride);
				break;
		}
	}

	// Footer:
	EndElm(ofs, tabs, itemlist->name.c_str());
}
//---------------------------------------------------------------------------

void _item_header(std::ofstream &ofs, int tabs, abakt::TItem* item, bool includeOverride)
{
	Tabs(ofs, tabs);
	ofs	<< "<" << ELM_item << " ";
	if (includeOverride)
		ofs << ATR_item_override << "='" << ecc::BoolToStr(item->override).c_str() << "' ";
	ofs	<< ATR_item_name << "='" << item->name.c_str() << "' ";
}
//---------------------------------------------------------------------------

void itemBool(std::ofstream &ofs, int tabs, abakt::TBool* item, bool includeOverride)
{
	_item_header(ofs, tabs, (abakt::TItem*)item, includeOverride);
	ofs	<< ATR_item_datatype << "='bool' "
		<< ATR_item_data << "='" << ecc::BoolToStr(item->value).c_str() << "'";
	ofs << "/>" << std::endl;
}
//---------------------------------------------------------------------------

void itemUIntRange(std::ofstream &ofs, int tabs, abakt::TUIntRange* item, bool includeOverride)
{
	_item_header(ofs, tabs, (abakt::TItem*)item, includeOverride);
	ofs	<< ATR_item_datatype << "='int' "
		<< ATR_item_data << "='" << IntToStr(item->get()).c_str() << "'";
	ofs << "/>" << std::endl;
}
//---------------------------------------------------------------------------

void itemText(std::ofstream &ofs, int tabs, abakt::TText* item, bool includeOverride)
{
	_item_header(ofs, tabs, (abakt::TItem*)item, includeOverride);
	String str(item->value);
	ofs	<< ATR_item_datatype << "='string' "
		<< ATR_item_data << "='" << ecc::StrToXmlUtf8Str(str).c_str() << "'";
	ofs << "/>" << std::endl;
}
//---------------------------------------------------------------------------

void itemPath(std::ofstream &ofs, int tabs, abakt::TPath* item, bool includeOverride)
{
	_item_header(ofs, tabs, (abakt::TItem*)item, includeOverride);
	String str(item->value);
	ofs	<< ATR_item_datatype << "='string' "
		<< ATR_item_data << "='" << ecc::StrToXmlUtf8Str(str).c_str() << "'";
	ofs << "/>" << std::endl;
}
//---------------------------------------------------------------------------

void itemEnum(std::ofstream &ofs, int tabs, abakt::TEnum* item, bool includeOverride)
{
	_item_header(ofs, tabs, (abakt::TItem*)item, includeOverride);
	ofs	<< ATR_item_datatype << "='string' "
		<< ATR_item_data << "='" << item->at(item->getIndex()).c_str() << "'";
	ofs << "/>" << std::endl;
}
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

void Tabs(std::ofstream &ofs, int tabs)
{
	if (tabs < 0)
		tabs = 0; // Default.

	for (tabs; tabs > 0; tabs--)
		ofs << "\t";
}
//---------------------------------------------------------------------------

void StartElm(std::ofstream &ofs, int tabs, const char* elm_name)
{
	Tabs(ofs, tabs);
	ofs << "<" << elm_name << ">" << std::endl;
}
//---------------------------------------------------------------------------

void EndElm(std::ofstream &ofs, int tabs, const char* elm_name)
{
	Tabs(ofs, tabs);
	ofs << "</" << elm_name << ">" << std::endl;
}
//---------------------------------------------------------------------------

void Elm(std::ofstream &ofs, int tabs, const char* elm_name,
		bool close)
{
	Tabs(ofs, tabs);
	ofs << "<" << elm_name
		<< (close ? "/" : "") << ">" << std::endl;
}
//---------------------------------------------------------------------------

void ElmBool(std::ofstream &ofs, int tabs, const char* elm_name, const bool val,
		bool close)
{
	Tabs(ofs, tabs);
	ofs << "<" << elm_name
		<< " bool='" << (val ? "true" : "false") << "'"
		<< (close ? "/" : "") << ">" << std::endl;
}
//---------------------------------------------------------------------------

void ElmInt(std::ofstream &ofs, int tabs, const char* elm_name, const long val,
		bool close)
{
	Tabs(ofs, tabs);
	ofs << "<" << elm_name
		<< " int='" << IntToStr(val).c_str() << "'"
		<< (close ? "/" : "") << ">" << std::endl;
}
//---------------------------------------------------------------------------

void ElmUInt(std::ofstream &ofs, int tabs, const char* elm_name, const unsigned long val,
		bool close)
{
	Tabs(ofs, tabs);
	ofs << "<" << elm_name
		<< " uint='" << IntToStr(val).c_str() << "'"
		<< (close ? "/" : "") << ">" << std::endl;
}
//---------------------------------------------------------------------------

void ElmEnum(std::ofstream &ofs, int tabs, const char* elm_name, const int val,
		bool close)
{
	Tabs(ofs, tabs);
	ofs << "<" << elm_name
		<< " enum='" << IntToStr(val).c_str() << "'"
		<< (close ? "/" : "") << ">" << std::endl;
}
//---------------------------------------------------------------------------

void ElmEnumStr(std::ofstream &ofs, int tabs, const char* elm_name, const String val,
		bool close)
{
	Tabs(ofs, tabs);
	ofs << "<" << elm_name
		<< " enum_str='" << ecc::StrToXmlUtf8Str(String(val)).c_str() << "'"
		<< (close ? "/" : "") << ">" << std::endl;
}
//---------------------------------------------------------------------------

void ElmStr(std::ofstream &ofs, int tabs, const char* elm_name, const String val,
		bool close)
{
	Tabs(ofs, tabs);
	ofs << "<" << elm_name
		<< " string='" << ecc::StrToXmlUtf8Str(String(val)).c_str() << "'"
		<< (close ? "/" : "") << ">" << std::endl;
}
//---------------------------------------------------------------------------

void Comment(std::ofstream &ofs, int tabs, const char* comment)
{
	Tabs(ofs, tabs);
	ofs << "<!-- " << comment << " -->" << std::endl;
}
//---------------------------------------------------------------------------

//===========================================================================
} // namespace xout;    CLOSE
//===========================================================================

//===========================================================================
namespace xin {
//===========================================================================

//---------------------------------------------------------------------------

void readSect_FileFilters_Filter_intoFSList(String elm, const char **attr,
        std::vector<TAbaktFilterSet> &fsList)
{
	if (elm != ELM_FF_Filter) return;

	String atr, val;
    TAbaktFilterSet fs;

	for (int i = 0; attr[i]; i += 2)
	{
		atr = String(attr[i]);
		val = String(attr[i+1]);
		if (atr == "name")
			fs.name = Utf8ToAnsi(val);
		if (atr == "enabled")
			fs.enabled = ecc::StrToBool(val);
		if (atr == "action")
			fs.action = StrToFilterSetAction(val);
		if (atr == "path")
			fs.path = Utf8ToAnsi(val);
		if (atr == "size")
			fs.size = val;
		if (atr == "date")
			fs.date = val;
		if (atr == "age")
			fs.age = val;
		if (atr == "attributes")
			fs.attributes = val;
	}

    // Add [fs] to [fsList]:
    fsList.push_back(fs);
}
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------

void itemAttrsToList(const char **attr, abakt::TItemList* itemlist) //, String itemName, String itemData, bool itemOverride)
{
	bool itemOverride = false;
	String itemName = "";
	String itemData = "";

	for (int i = 0; attr[i]; i += 2)
	{
		String atr(attr[i]);
		String val(attr[i+1]);
		if (atr == ATR_item_override)
			itemOverride = ecc::StrToBool(val);
		if (atr == ATR_item_name)
			itemName = val;
		if (atr == ATR_item_data)
			itemData = Utf8ToAnsi(val);
	}

	// ---

	int idx = itemlist->indexOfName(itemName.c_str());
	abakt::TItem* item = itemlist->at(idx);
	if (!item) return;

	item->override = itemOverride;
	switch (item->type())
	{
		case abakt::dtBool:
			((abakt::TBool*)item)->value = ecc::StrToBool(itemData);
			break;

		case abakt::dtUIntRange:
			((abakt::TUIntRange*)item)->set(StrToInt(itemData));
			break;

		case abakt::dtText:
			((abakt::TText*)item)->value = itemData.c_str();
			break;

		case abakt::dtPath:
			((abakt::TPath*)item)->value = itemData.c_str();
			break;

		case abakt::dtEnum:
			int enum_idx = ((abakt::TEnum*)item)->indexOf(itemData.c_str());
			if (enum_idx != -1)
				((abakt::TEnum*)item)->setIndex(enum_idx);
			break;
	}
}
//---------------------------------------------------------------------------

bool selected(const char **attr, const bool def)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == "selected")
			return ecc::StrToBool(attr[i + 1]);
	}
	return def;
}
//---------------------------------------------------------------------------

bool Bool(const char **attr, const bool def)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == "bool")
			return ecc::StrToBool(attr[i + 1]);
	}
	return def;
}
//---------------------------------------------------------------------------

long Int(const char **attr, const long def)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == "int")
			return StrToIntDef(attr[i + 1], def);
	}
	return def;
}
//---------------------------------------------------------------------------

unsigned long UInt(const char **attr, const unsigned long def)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == "uint")
			return StrToIntDef(attr[i + 1], def);
	}
	return def;
}
//---------------------------------------------------------------------------

int Enum(const char **attr, const int def)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == "enum")
			return StrToIntDef(attr[i + 1], def);
	}
	return def;
}
//---------------------------------------------------------------------------

String EnumStr(const char **attr)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == "enum_str")
			return Utf8ToAnsi( String(attr[i + 1]) );
	}
	return "";
}

//---------------------------------------------------------------------------

String Str(const char **attr)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == "string")
			return Utf8ToAnsi( String(attr[i + 1]) );
	}
	return "";
}
//---------------------------------------------------------------------------

bool AttrValBool(const String attr_name, const char **attr, const bool def)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == attr_name)
			return ecc::StrToBoolDef(String(attr[i + 1]), def);
	}
	return def;
}
//---------------------------------------------------------------------------

int AttrValInt(const String attr_name, const char **attr, const int def)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == attr_name)
			return StrToIntDef(String(attr[i + 1]), def);
	}
	return def;
}
//---------------------------------------------------------------------------

String AttrValStr(const String attr_name, const char **attr)
{
	for (int i = 0; attr[i]; i += 2)
	{
		if (String(attr[i]) == attr_name)
			return Utf8ToAnsi( String(attr[i + 1]) );
	}
	return "";
}
//---------------------------------------------------------------------------

//===========================================================================
} // namespace xin;     CLOSE
//===========================================================================

